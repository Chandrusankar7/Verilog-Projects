#include "fp_mul_pow2.h"

#ifdef ABS
#undef ABS
#endif
#define ABS(n) ((n < 0) ? -n : n)

float float_mul_pow2(float x, int8_t n)
{
#pragma AP inline // Always inline this function
   float_num_t x_num, prod;

   x_num.fp_num = x;
#ifndef AESL_FP_MATH_NO_BOUNDS_TESTS
   if (x_num.bexp == 0xFF || x_num.bexp == 0) // pass through NaN, INF & denorm
      prod.fp_num = x_num.fp_num;
   else if (n >= 0 && x_num.bexp >= 255 - n) { // detect and handle overflow
      prod.sign = x_num.sign; //
      prod.bexp = 0xFF;       // +/-INF
      prod.mant = 0;          //
   } else if (n < 0 && x_num.bexp <= ABS(n)) { // handle underflow (doesn't gen denorms)
      prod.sign = x_num.sign; //
      prod.bexp = 0;          // +/-ZERO
      prod.mant = 0;          //
   } else
#endif // AESL_FP_MATH_NO_BOUNDS_TESTS not defined
   {
      prod.sign = x_num.sign;
      prod.bexp = x_num.bexp + n;
      prod.mant = x_num.mant;
   }
   return prod.fp_num;
}

double double_mul_pow2(double x, int16_t n)
{
#pragma AP inline // Always inline this function
   double_num_t x_num, prod;

   x_num.fp_num = x;
#ifndef AESL_FP_MATH_NO_BOUNDS_TESTS
   if (x_num.bexp == 0xFF || x_num.bexp == 0) // pass through NaN, INF & denorm
      prod.fp_num = x_num.fp_num;
   else if (n >= 0 && x_num.bexp >= 2047 - n) { // detect and handle overflow
      prod.sign = x_num.sign; //
      prod.bexp = 0x7FF;      // +/-INF
      prod.mant = 0;          //
   } else if (n < 0 && x_num.bexp <= ABS(n)) { // handle underflow (doesn't gen denorms)
      prod.sign = x_num.sign; //
      prod.bexp = 0;          // +/-ZERO
      prod.mant = 0;          //
   } else
#endif // AESL_FP_MATH_NO_BOUNDS_TESTS not defined
   {
      prod.sign = x_num.sign;
      prod.bexp = x_num.bexp + n;
      prod.mant = x_num.mant;
   }
   return prod.fp_num;
}


//////////////////////////////////////////////////////////////

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include "fp_mul_pow2.h"

#define NUM_TEST_ITERS 16

// Simple test program to validate SW models and for re-use in RTL co-simulation
int main(void)
{
   double test_val = 1.5;
   int16_t test_exp = -15;
   double_num_t hw_result, sw_result;
   unsigned i, err_cnt = 0;

   for (i = 0; i < NUM_TEST_ITERS; i++) {
      // Get result from HW version
      hw_result.fp_num = double_mul_pow2(test_val, test_exp);
      // Generate expected result
      sw_result.fp_num =  test_val * pow(2.0, test_exp);
      // Print out result
      printf("hw_result = %13g : bits = 0x%016llX : ",
            hw_result.fp_num,
            (unsigned long long)hw_result.raw_bits);
      printf("sign = %c, exp = %5d, mant = 0x%014llX",
            hw_result.sign ? '-' : '+',
            (int)hw_result.bexp - 1023,
            (unsigned long long)hw_result.mant
      );
      // Check for mismatch
      if (hw_result.fp_num != sw_result.fp_num) {
         err_cnt++;
         printf(" !!! MISMATCH !!!\n");
         printf("sw_result = %13g : bits = 0x%016llX : ",
               sw_result.fp_num,
               (unsigned long long)sw_result.raw_bits);
         printf("sign = %c, exp = %5d, mant = 0x%014llX\n",
               sw_result.sign ? '-' : '+',
               (int)sw_result.bexp - 1023,
               (unsigned long long)sw_result.mant
         );
      } else {
         printf("\n");
      }
// Generate new inputs
      test_val = ((RAND_MAX / 2) - rand()) / (float)rand();
      test_exp = 1023 - (rand() & 0x7FF);
   }

   // Print final test status
   if (err_cnt)
      printf("!!! TEST FAILED !!!\n");
   else
      printf("* Test passed *\n");
   // Return 0 only on success
   if (err_cnt)
       return 1;
   else
       return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////




// ==============================================================
// RTL generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
// Version: 2014.4
// Copyright (C) 2014 Xilinx Inc. All rights reserved.
// 
// ===========================================================

`timescale 1 ns / 1 ps 

(* CORE_GENERATION_INFO="double_mul_pow2,hls_ip_2014_4,{HLS_INPUT_TYPE=c,HLS_INPUT_FLOAT=1,HLS_INPUT_FIXED=0,HLS_INPUT_PART=xc7k160tfbg484-1,HLS_INPUT_CLOCK=5.000000,HLS_INPUT_ARCH=others,HLS_SYN_CLOCK=4.200000,HLS_SYN_LAT=1,HLS_SYN_TPT=none,HLS_SYN_MEM=0,HLS_SYN_DSP=0,HLS_SYN_FF=72,HLS_SYN_LUT=395}" *)

module double_mul_pow2 (
        ap_clk,
        ap_rst,
        ap_start,
        ap_done,
        ap_idle,
        ap_ready,
        x,
        n,
        ap_return
);

parameter    ap_const_logic_1 = 1'b1;
parameter    ap_const_logic_0 = 1'b0;
parameter    ap_ST_st1_fsm_0 = 2'b1;
parameter    ap_ST_st2_fsm_1 = 2'b10;
parameter    ap_const_lv32_0 = 32'b00000000000000000000000000000000;
parameter    ap_const_lv1_1 = 1'b1;
parameter    ap_const_lv32_34 = 32'b110100;
parameter    ap_const_lv32_3E = 32'b111110;
parameter    ap_const_lv32_F = 32'b1111;
parameter    ap_const_lv17_7FF = 17'b11111111111;
parameter    ap_const_lv32_3F = 32'b111111;
parameter    ap_const_lv17_0 = 17'b00000000000000000;
parameter    ap_const_lv11_FF = 11'b11111111;
parameter    ap_const_lv11_0 = 11'b00000000000;
parameter    ap_const_lv63_0 = 63'b000000000000000000000000000000000000000000000000000000000000000;
parameter    ap_const_lv32_1 = 32'b1;
parameter    ap_const_lv64_7FF0000000000000 = 64'b111111111110000000000000000000000000000000000000000000000000000;
parameter    ap_true = 1'b1;

input   ap_clk;
input   ap_rst;
input   ap_start;
output   ap_done;
output   ap_idle;
output   ap_ready;
input  [63:0] x;
input  [15:0] n;
output  [63:0] ap_return;

reg ap_done;
reg ap_idle;
reg ap_ready;
(* fsm_encoding = "none" *) reg   [1:0] ap_CS_fsm = 2'b1;
reg    ap_sig_cseq_ST_st1_fsm_0;
reg    ap_sig_bdd_18;
reg   [0:0] tmp_1_reg_252;
wire   [0:0] tmp_7_fu_97_p2;
reg   [0:0] tmp_7_reg_258;
reg   [0:0] tmp_3_reg_264;
reg   [0:0] tmp_4_reg_269;
wire   [63:0] tmp_10_fu_149_p5;
reg   [63:0] tmp_10_reg_274;
wire   [0:0] slt_fu_161_p2;
reg   [0:0] slt_reg_279;
wire   [0:0] sel_tmp8_fu_179_p2;
reg   [0:0] sel_tmp8_reg_284;
wire   [63:0] tmp_fu_61_p1;
wire   [10:0] tmp_2_cast_fu_65_p4;
wire   [16:0] tmp_5_cast_fu_87_p1;
wire   [16:0] tmp_3_cast_fu_75_p1;
wire   [16:0] tmp_6_fu_91_p2;
wire  signed [16:0] tmp_10_cast_fu_119_p1;
wire   [10:0] tmp_5_fu_129_p4;
wire   [10:0] tmp_8_fu_139_p1;
wire   [10:0] tmp_11_fu_143_p2;
wire  signed [16:0] tmp_2_fu_123_p2;
wire   [0:0] sel_tmp9_fu_167_p2;
wire   [0:0] sel_tmp4_fu_173_p2;
reg    ap_sig_cseq_ST_st2_fsm_1;
reg    ap_sig_bdd_113;
wire   [63:0] tmp_9_fu_185_p3;
wire   [0:0] sel_tmp1_demorgan_fu_198_p2;
wire   [63:0] tmp_s_fu_192_p2;
wire   [0:0] rev_fu_209_p2;
wire   [0:0] sel_tmp6_fu_214_p2;
wire   [0:0] tmp1_fu_218_p2;
wire   [0:0] sel_tmp7_fu_224_p2;
wire   [63:0] sel_tmp2_fu_202_p3;
wire   [63:0] prod_1_in_fu_229_p3;
wire   [63:0] prod_1_fu_237_p1;
reg   [1:0] ap_NS_fsm;




/// the current state (ap_CS_fsm) of the state machine. ///
always @ (posedge ap_clk)
begin : ap_ret_ap_CS_fsm
    if (ap_rst == 1'b1) begin
        ap_CS_fsm <= ap_ST_st1_fsm_0;
    end else begin
        ap_CS_fsm <= ap_NS_fsm;
    end
end

/// assign process. ///
always @(posedge ap_clk)
begin
    if (((ap_const_logic_1 == ap_sig_cseq_ST_st1_fsm_0) & ~(ap_start == ap_const_logic_0))) begin
        sel_tmp8_reg_284 <= sel_tmp8_fu_179_p2;
        slt_reg_279 <= slt_fu_161_p2;
        tmp_10_reg_274 <= tmp_10_fu_149_p5;
        tmp_1_reg_252 <= n[ap_const_lv32_F];
        tmp_3_reg_264 <= n[ap_const_lv32_F];
        tmp_4_reg_269 <= tmp_fu_61_p1[ap_const_lv32_3F];
        tmp_7_reg_258 <= tmp_7_fu_97_p2;
    end
end

/// ap_done assign process. ///
always @ (ap_sig_cseq_ST_st2_fsm_1)
begin
    if ((ap_const_logic_1 == ap_sig_cseq_ST_st2_fsm_1)) begin
        ap_done = ap_const_logic_1;
    end else begin
        ap_done = ap_const_logic_0;
    end
end

/// ap_idle assign process. ///
always @ (ap_start or ap_sig_cseq_ST_st1_fsm_0)
begin
    if ((~(ap_const_logic_1 == ap_start) & (ap_const_logic_1 == ap_sig_cseq_ST_st1_fsm_0))) begin
        ap_idle = ap_const_logic_1;
    end else begin
        ap_idle = ap_const_logic_0;
    end
end

/// ap_ready assign process. ///
always @ (ap_sig_cseq_ST_st2_fsm_1)
begin
    if ((ap_const_logic_1 == ap_sig_cseq_ST_st2_fsm_1)) begin
        ap_ready = ap_const_logic_1;
    end else begin
        ap_ready = ap_const_logic_0;
    end
end

/// ap_sig_cseq_ST_st1_fsm_0 assign process. ///
always @ (ap_sig_bdd_18)
begin
    if (ap_sig_bdd_18) begin
        ap_sig_cseq_ST_st1_fsm_0 = ap_const_logic_1;
    end else begin
        ap_sig_cseq_ST_st1_fsm_0 = ap_const_logic_0;
    end
end

/// ap_sig_cseq_ST_st2_fsm_1 assign process. ///
always @ (ap_sig_bdd_113)
begin
    if (ap_sig_bdd_113) begin
        ap_sig_cseq_ST_st2_fsm_1 = ap_const_logic_1;
    end else begin
        ap_sig_cseq_ST_st2_fsm_1 = ap_const_logic_0;
    end
end
/// the next state (ap_NS_fsm) of the state machine. ///
always @ (ap_start or ap_CS_fsm)
begin
    case (ap_CS_fsm)
        ap_ST_st1_fsm_0 : 
        begin
            if (~(ap_start == ap_const_logic_0)) begin
                ap_NS_fsm = ap_ST_st2_fsm_1;
            end else begin
                ap_NS_fsm = ap_ST_st1_fsm_0;
            end
        end
        ap_ST_st2_fsm_1 : 
        begin
            ap_NS_fsm = ap_ST_st1_fsm_0;
        end
        default : 
        begin
            ap_NS_fsm = 'bx;
        end
    endcase
end

assign ap_return = ((sel_tmp8_reg_284)? x: prod_1_fu_237_p1);

/// ap_sig_bdd_113 assign process. ///
always @ (ap_CS_fsm)
begin
    ap_sig_bdd_113 = (ap_const_lv1_1 == ap_CS_fsm[ap_const_lv32_1]);
end

/// ap_sig_bdd_18 assign process. ///
always @ (ap_CS_fsm)
begin
    ap_sig_bdd_18 = (ap_CS_fsm[ap_const_lv32_0] == ap_const_lv1_1);
end
assign prod_1_fu_237_p1 = prod_1_in_fu_229_p3;
assign prod_1_in_fu_229_p3 = ((sel_tmp7_fu_224_p2)? tmp_9_fu_185_p3: sel_tmp2_fu_202_p3);
assign rev_fu_209_p2 = (slt_reg_279 ^ ap_const_lv1_1);
assign sel_tmp1_demorgan_fu_198_p2 = (tmp_1_reg_252 | tmp_7_reg_258);
assign sel_tmp2_fu_202_p3 = ((sel_tmp1_demorgan_fu_198_p2)? tmp_10_reg_274: tmp_s_fu_192_p2);
assign sel_tmp4_fu_173_p2 = (tmp_2_cast_fu_65_p4 == ap_const_lv11_0? 1'b1: 1'b0);
assign sel_tmp6_fu_214_p2 = (tmp_7_reg_258 | tmp_1_reg_252);
assign sel_tmp7_fu_224_p2 = (tmp1_fu_218_p2 & tmp_3_reg_264);
assign sel_tmp8_fu_179_p2 = (sel_tmp9_fu_167_p2 | sel_tmp4_fu_173_p2);
assign sel_tmp9_fu_167_p2 = (tmp_2_cast_fu_65_p4 == ap_const_lv11_FF? 1'b1: 1'b0);
assign slt_fu_161_p2 = ($signed(tmp_2_fu_123_p2) < $signed(tmp_3_cast_fu_75_p1)? 1'b1: 1'b0);
assign tmp1_fu_218_p2 = (rev_fu_209_p2 & sel_tmp6_fu_214_p2);
assign tmp_10_cast_fu_119_p1 = $signed(n);
assign tmp_10_fu_149_p5 = {{tmp_fu_61_p1[32'd63 : 32'd63]}, {tmp_11_fu_143_p2}, {tmp_fu_61_p1[32'd51 : 32'd0]}};
assign tmp_11_fu_143_p2 = (tmp_5_fu_129_p4 + tmp_8_fu_139_p1);
assign tmp_2_cast_fu_65_p4 = {{tmp_fu_61_p1[ap_const_lv32_3E : ap_const_lv32_34]}};
assign tmp_2_fu_123_p2 = ($signed(ap_const_lv17_0) - $signed(tmp_10_cast_fu_119_p1));
assign tmp_3_cast_fu_75_p1 = tmp_2_cast_fu_65_p4;
assign tmp_5_cast_fu_87_p1 = n;
assign tmp_5_fu_129_p4 = {{tmp_fu_61_p1[ap_const_lv32_3E : ap_const_lv32_34]}};
assign tmp_6_fu_91_p2 = (ap_const_lv17_7FF - tmp_5_cast_fu_87_p1);
assign tmp_7_fu_97_p2 = ($signed(tmp_3_cast_fu_75_p1) < $signed(tmp_6_fu_91_p2)? 1'b1: 1'b0);
assign tmp_8_fu_139_p1 = n[10:0];
assign tmp_9_fu_185_p3 = {{tmp_4_reg_269}, {ap_const_lv63_0}};
assign tmp_fu_61_p1 = x;
assign tmp_s_fu_192_p2 = (tmp_9_fu_185_p3 | ap_const_lv64_7FF0000000000000);


endmodule //double_mul_pow2





***************************/
#ifndef FLOAT_MUL_POW2_H_
#define FLOAT_MUL_POW2_H_

#include <stdint.h>

// Uncomment the following line to eliminate bounds checking, ignoring 
// overlow, underflow, NaN inputs, etc.
//#define AESL_FP_MATH_NO_BOUNDS_TESTS

// Helper typedefs that allow easy parsing of the IEEE-754 floating point
// format fields (sign, biased exponent and mantissa), via C bit-fields, as 
// well as directly manipulating the whole word bitfield ('raw_bits').
typedef union {
   float fp_num;
   uint32_t raw_bits;
   struct {
      uint32_t mant : 23;
      uint32_t bexp : 8;
      uint32_t sign : 1;
   };
} float_num_t;

typedef union {
   double fp_num;
   uint64_t raw_bits;
   struct {
      uint64_t mant : 52;
      uint64_t bexp : 11;
      uint64_t sign : 1;
   };
} double_num_t;

// These functions implement floating point (single- and double-precision)
// multiplication by a power-of-two for HLS. Multiplication by a power-of-two
// can be much more effecient that arbitrary multiplitcation, because it can
// be reduced to a simple 8- or 11-bit (single- & double-precision
// respectively) addition to the biased exponent w/ some basic checks for
// overflow and underflow (which can be eliminated if desired by defining the
// preprocessor macro AESL_FP_MATH_NO_BOUNDS_TESTS.
float float_mul_pow2(float x, int8_t n);
double double_mul_pow2(double x, int16_t n);

#endif // FLOAT_MUL_POW2_H_